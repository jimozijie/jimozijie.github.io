# java工作积累
## 1.springboot框架相关

### 1.1. jdk17安装

jdk17安装（推荐版本）

[https://blog.csdn.net/YangCunle/article/details/135813423?fromshare=blogdetail&sharetype=blogdetail&sharerId=135813423&sharerefer=PC&sharesource=qq_60200158&sharefrom=from_link](https://blog.csdn.net/m0_52861000/article/details/125820297)


### 1.2. lombok.Builder与java建造者模式

在构建对象的时候，如果对象属性比较多，一般有几种构造方法

1. 使用一个构造器
2. 一个空的构造器，然后使用setter方法进行设置。
3. 使用builder建造者模式

如果一个类被频繁的使用：
```java
public class Result<T> {
    private int code;
    private String message;
    private T data;

    public Result(int code, String message, T data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    public Result() {
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return "Result{" +
                "code=" + code +
                ", message='" + message + '\'' +
                ", data=" + data +
                '}';
    }
}


```
我们在使用这个类的时候，一般的方法是如下：

```java
public class Main {
    public static void main(String[] args) {
        //方法1，使用全量的构造函数
        // 弊端：当只需要部分参数的时候需要再定义个构造函数（比如失败的情况只需要code和message，结果肯定是空，因此不需要data），且一旦参数较多，则构造函数冗长；
        Result<String> result1 = new Result<>(200, "success", "");
        

        //方法2，使用空的构造函数加setter函数赋值
        // setter冗长；在类里面，每个变量都要设置set方法和get方法
        Result<String> result2 = new Result<>();
        result2.setCode(200);
        result2.setMessage("success");
        result2.setData("");
    }
}

```

使用lombok.Builder优化：
```java
import lombok.AllArgsConstructor;
import lombok.Builder;  
import lombok.Data;
import lombok.NoArgsConstructor;

// 在类上面加上@Builder注解
@Data
@Builder    
@NoArgsConstructor
@AllArgsConstructor
public class Result<T> {
    private int code;
    private String message;
    private T data;
}


```

构造类时只要这样就行了
这样想给几个参数设置初始值就设置几个。非常方便
```java
Result<String> result5 = Result.<String>builder()
        .code(404)
        .message("failure")
        .build();
```



### 1.3 JWT工具类模板及其使用

在Spring Boot项目中，JWT（JSON Web Token）是常用的无状态身份验证方案。下面是完整的JWT实现模板及其使用方式：

#### 一、JWT工具类模板 (JwtUtil.java)

```java
package com.sky.utils;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.JwtBuilder;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import java.nio.charset.StandardCharsets;
import java.util.Date;
import java.util.Map;

public class JwtUtil {
    /**
     * 生成jwt
     * 使用Hs256算法, 私匙使用固定秘钥
     *
     * @param secretKey jwt秘钥
     * @param ttlMillis jwt过期时间(毫秒)
     * @param claims    设置的信息
     * @return
     */
    public static String createJWT(String secretKey, long ttlMillis, Map<String, Object> claims) {
        // 指定签名的时候使用的签名算法，也就是header那部分
        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;

        // 生成JWT的时间
        long expMillis = System.currentTimeMillis() + ttlMillis;
        Date exp = new Date(expMillis);

        // 设置jwt的body
        JwtBuilder builder = Jwts.builder()
                // 如果有私有声明，一定要先设置这个自己创建的私有的声明，这个是给builder的claim赋值，一旦写在标准的声明赋值之后，就是覆盖了那些标准的声明的
                .setClaims(claims)
                // 设置签名使用的签名算法和签名使用的秘钥
                .signWith(signatureAlgorithm, secretKey.getBytes(StandardCharsets.UTF_8))
                // 设置过期时间
                .setExpiration(exp);

        return builder.compact();
    }

    /**
     * Token解密
     *
     * @param secretKey jwt秘钥 此秘钥一定要保留好在服务端, 不能暴露出去, 否则sign就可以被伪造, 如果对接多个客户端建议改造成多个
     * @param token     加密后的token
     * @return
     */
    public static Claims parseJWT(String secretKey, String token) {
        // 得到DefaultJwtParser
        Claims claims = Jwts.parser()
                // 设置签名的秘钥
                .setSigningKey(secretKey.getBytes(StandardCharsets.UTF_8))
                // 设置需要解析的jwt
                .parseClaimsJws(token).getBody();
        return claims;
    }

}

```

#### 二、核心功能说明

| 方法        | 参数说明                                                     | 返回值     | 功能描述                          |
| ----------- | ------------------------------------------------------------ | ---------- | --------------------------------- |
| `createJWT` | `secretKey`: HS256算法的签名密钥<br>`ttlMillis`: 令牌有效期（毫秒）<br>`claims`: 自定义数据（键值对） | String     | 生成包含自定义数据和过期时间的JWT |
| `parseJWT`  | `secretKey`: 验证密钥<br>`token`: JWT令牌字符串              | Claims对象 | 验证并解析JWT，提取声明数据       |

#### 三、JWT在项目中的完整使用流程

##### 1. 配置文件 (application.yml)

一般后端的秘钥，还有令牌的有效期，名称等都是写在配置文件中，可自由设定

这个配置文件application.yml的路径一般在项目的src/main/resources/application.yml上

```yaml
sky:
  jwt:
    admin-secret-key: your_strong_secret_here # 管理员端密钥
    admin-ttl: 7200000 # 令牌有效期(2小时)
    admin-token-name: token # 前端传递令牌的请求头名称
```

然后可以创建一个类（文件名为JwtProperties.java）来接收配置文件的参数：

```java
package com.sky.properties;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "sky.jwt")	//这里代表从配置文件里面读取参数，转化为类内参数
@Data
public class JwtProperties {

    /**
     * 管理端员工生成jwt令牌相关配置
     */
    private String adminSecretKey;
    private long adminTtl;
    private String adminTokenName;

    /**
     * 用户端微信用户生成jwt令牌相关配置
     */
    private String userSecretKey;
    private long userTtl;
    private String userTokenName;

}
```



##### 2. 登录接口生成令牌 (EmployeeController.java)

```java
@PostMapping("/login")
public Result<EmployeeLoginVO> login(@RequestBody EmployeeLoginDTO dto) {
    // 1. 验证用户凭证
    Employee employee = employeeService.login(dto);
    
    // 2. 准备JWT声明数据
    // 创建一个 Map 对象用于存储 JWT 的声明（payload 部分）
    Map<String, Object> claims = new HashMap<>();
    // 向 claims 中添加员工ID声明：键为常量 EMP_ID，值为员工对象ID
    claims.put(JwtClaimsConstant.EMP_ID, employee.getId());
    
    // 3. 生成JWT令牌
    String token = JwtUtil.createJWT(
        jwtProperties.getAdminSecretKey(),   // 从配置读取密钥
        jwtProperties.getAdminTtl(),         // 从配置读取有效期
        claims                              // 包含员工ID的声明数据
    );
    
    // 4. 返回令牌给客户端
    // 使用建造者模式构建返回给前端的响应对象
    EmployeeLoginVO employeeLoginVO = EmployeeLoginVO.builder()
            .id(employee.getId())       // 设置员工ID
            .userName(employee.getUsername()) // 设置用户名
            .name(employee.getName())   // 设置真实姓名
            .token(token)               // 设置生成的JWT令牌
            .build();                   // 构建不可变对象

    return Result.success(employeeLoginVO);
}
```

##### 3. 拦截器验证令牌 (JwtTokenAdminInterceptor.java)
```java
package com.sky.interceptor;

import com.sky.constant.JwtClaimsConstant;
import com.sky.context.BaseContext;
import com.sky.properties.JwtProperties;
import com.sky.utils.JwtUtil;
import io.jsonwebtoken.Claims;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.web.method.HandlerMethod;
import org.springframework.web.servlet.HandlerInterceptor;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * jwt令牌校验的拦截器
 */
@Component
@Slf4j
public class JwtTokenAdminInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtProperties jwtProperties;

    /**
     * 校验jwt
     *
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {

        System.out.println("当前线程的id："+Thread.currentThread().getId());

        //判断当前拦截到的是Controller的方法还是其他资源
        if (!(handler instanceof HandlerMethod)) {
            //当前拦截到的不是动态方法，直接放行
            return true;
        }

        //1、从请求头中获取令牌
        String token = request.getHeader(jwtProperties.getAdminTokenName());

        //2、校验令牌
        try {
            log.info("jwt校验:{}", token);
            Claims claims = JwtUtil.parseJWT(jwtProperties.getAdminSecretKey(), token);
            Long empId = Long.valueOf(claims.get(JwtClaimsConstant.EMP_ID).toString());
            log.info("当前员工id：", empId);
            BaseContext.setCurrentId(empId);

            //3、通过，放行
            return true;
        } catch (Exception ex) {
            //4、不通过，响应401状态码
            response.setStatus(401);
            return false;
        }
    }
}

```

#### 四、核心设计要点

1. **声明数据标准化**
   ```java
   // 声明常量类（避免魔法值）
   public class JwtClaimsConstant {
       public static final String EMP_ID = "empId";
   }
   ```

2. **密钥安全管理**
   - 通过配置类集中管理密钥
   - 不同客户端使用不同密钥（如admin/用户端分离）
   - 密钥使用字节数组防止编码问题

> **总结**：该JWT实现模板提供了完整的身份验证解决方案，包括令牌生成、验证、用户身份传递和安全防护措施。在实际项目中，可根据需求扩展令牌刷新机制、多设备管理和权限控制等功能。



#### 五、典型使用场景

| 场景           | JWT应用方式                   |
| -------------- | ----------------------------- |
| 用户认证       | 登录成功后返回包含用户ID的JWT |
| API访问控制    | 拦截器验证请求头中的JWT       |
| 微服务间通信   | 服务间传递包含身份信息的JWT   |
| 无状态会话管理 | 替代Session存储用户状态       |
| 临时授权令牌   | 生成短期有效的资源访问令牌    |





### 1.4 @ConfigurationProperties注解原理

在 SpringBoot 中，当想需要获取到配置文件数据时，除了可以用 Spring 自带的 @Value 注解外，SpringBoot 还提供了一种更加方便的方式：@ConfigurationProperties。

只要在类上添加上了这个注解，指定好配置文件的前缀，那么对应的配置文件数据就会自动填充到类中对应的变量中。

​    比如在application.properties文件中有如下配置文件

```properties
config.username=jay.zhou
config.password=3333
```

那么按照如下注解配置，SpringBoot项目中使用@ConfigurationProperties的Bean

它的username与password就会被自动注入值了。就像下面展示的那样

```java
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

@Component
@ConfigurationProperties(prefix = "config")
public class TestBean{
    private String username;

    private String password;
}
```



### 1.5 @Data注解

**引入依赖：**

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.18.4</version>
    <scope>provided</scope>
</dependency>
```

@Data 是一个 Lombok 提供的注解，它可以自动为类生成常用的方法，包括 getter、setter、equals、hashCode 和 toString 等。使用 @Data 注解可以简化代码，使代码更加简洁易读。

在类上添加 @Data 注解后，Lombok 会自动生成以下方法：

- 所有字段的 getter 和 setter 方法。
- equals 和 hashCode 方法，用于比较两个对象是否相等。
- toString 方法，用于将对象转换为字符串表示形式。

例如，下面这个 Java 类：

```java
@Data
public class User {
    private String name;
    private int age;
}
 
```

使用 @Data 注解后，Lombok 会自动生成以下代码：

```java
public class User {
    private String name;
    private int age;
    
    public String getName() {
        return this.name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return this.age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object obj) {
        // ...
    }

    @Override
    public int hashCode() {
        // ...
    }

    @Override
    public String toString() {
        // ...
    }
}
```

   

使用 @Data 注解还可以为类生成其他方法，例如带参构造函数、无参构造函数、builder 方法等。

可以通过在注解中配置参数来控制生成哪些方法。

例如，@Data 注解默认会生成一个无参构造函数，可以通过设置 @Data(staticConstructor = "of") 来生成一个带参的静态构造函数。

@Data 注解适用于大部分的 Java 类，特别是那些只包含属性和简单逻辑的 POJO（Plain Old Java Object）类。

它可以使代码更加简洁易读，减少冗余代码，提高开发效率。

但需要注意的是，由于 @Data 注解会自动生成大量的代码，如果类中包含大量字段，可能会影响编译速度和性能。

此外，@Data 注解也不适合用于一些需要手动实现 getter 和 setter 方法，或需要对 equals 和 hashCode 方法进行特殊定制的场景。


## 2. docsify项目部署

**本网页就是使用docsify框架生成的静态资源Wiki网站**


### 2.1docsify本地预览
  1. 本地预览网站命令
  ```bash
  docsify serve docs
  ```

## 3.Redis相关

### 3.1 redis 本地启动

```bash
# 启动Redis服务
redis-server.exe redis
# 退出Redis服务 ctrl+c
```

